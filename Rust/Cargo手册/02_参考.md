# Cargo 参考

## 指定依赖

默认情况下，Cargo 是准备好，在[crates.io](https://crates.io/)上查找依赖项。在这种情况下，只需要名称和版本字符串。在[Cargo 指南](https://rustwiki.org/zh-CN/cargo/guide/index.html)，我们选择了一个依赖项-`time`箱:

```toml
[dependencies]
time = "0.1.12"
```

字符串`"0.1.12"`是一个[semver](https://github.com/steveklabnik/semver#requirements)版本格式字符串。由于此字符串中没有任何运算符，因此它的解释方式与我们指定的`"^0.1.12"`方式相同，而`^`被称为跳脱条件.

### Caret requirements(跳脱条件)

**跳脱条件**: 允许 SemVer 兼容更新指定版本。新的版本允许更新的条件是，不修改最左边的非零数字(无论`major，minor，patch`)。在这种情况下，如果我们执行了`cargo update -p time`，Cargo 应该更新我们的`0.1.13`版本(如果是最新的`0.1.z`发布)，但不会更新为`0.2.0`。相反，我们若将版本字符串指定为`^1.0`，Cargo 应更新至`1.1`，如果是最新的`1.y`发布，但不是`2.0`版本。`0.0.x`并不与任何其他版本兼容.

以下是一些跳脱条件的例子以及它们允许的版本:

```
^1.2.3 := >=1.2.3 <2.0.0
^1.2 := >=1.2.0 <2.0.0
^1 := >=1.0.0 <2.0.0
^0.2.3 := >=0.2.3 <0.3.0
^0.2 := >= 0.2.0 < 0.3.0
^0.0.3 := >=0.0.3 <0.0.4
^0.0 := >=0.0.0 <0.1.0
^0 := >=0.0.0 <1.0.0
```

此兼容性约定与 SemVer ，在处理 1.0.0 之前的版本方面有所不同。虽然 SemVer 说在 1.0.0 之前没有兼容性，但 Cargo 认为`0.x.y`是兼容`0.x.z`，这里`y ≥ z`和`x > 0`.

### Tilde条件

**Tilde 条件**指定具有更新最小版本的一定能力。如果指定 major 版本，minor 版本和 patch 程序版本，或仅指定 major 版本和 minor 版本，则仅允许 patch 程序级别更改。如果仅指定 major 版本，则允许进行 minor 和 patch 级别更改.

`~1.2.3`是 Tilde 条件的一个例子.

```
~1.2.3 := >=1.2.3 <1.3.0
~1.2 := >=1.2.0 <1.3.0
~1 := >=1.0.0 <2.0.0
```

### 通配符要求

**通配符条件**允许任何通配符所在的版本.

`*`，`1.*`和`1.2.*`是通配符条件的示例.

```notrust
* := >=0.0.0
1.* := >=1.0.0 <2.0.0
1.2.* := >=1.2.0 <1.3.0
```

### Inequality requirements(范围条件)

**范围条件**允许手动指定要依赖的版本范围或确切版本.

以下是范围条件的一些示例:

```notrust
>= 1.2.0
> 1
< 2
= 1.2.3
```

### 多版本条件

多个版本，要求用逗号分隔，例如`>= 1.2， < 1.5`.

### 依赖指定, 来自git存储库

依赖于位于`git`存储库的库，您需要指定的最小信息，为一个`git`字段，其是存储库的`github`位置:

```toml
[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand" }
```

Cargo 将取得`git`，然后在这个位置找到一个存储库的请求箱子的`Cargo.toml`。方式是对`git`存储库里面的任何地方(不一定在根目录) - 例如，指定工作区中的成员包名称，和设置`git`到包含工作区的存储库).

由于我们尚未指定任何其他信息，因此 Cargo 假定我们打算使用最新的提交`master`分支，来构建我们的包。你可以将`git`字段和`rev`，`tag`， 还有`branch`，这些用于指定其他内容的字段组合起来。这是一个指定您希望在名为`next`分支上，使用最新提交的示例:

```toml
[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" }
```

### 依赖指定, 路径

随着时间的推移，我们来自[指南](https://rustwiki.org/zh-CN/cargo/guide/index.html)的`hello_world`示例已大幅增长! 它已经到了我们可能想分出一个单独的箱子供其他人使用的地步。为此，Cargo 支持**路径依赖**通常是位于一个存储库中的子箱。让我们开始在`hello_world`包的内部制作一个新的箱子:

```console
# inside of hello_world/
$ cargo new hello_utils
```

这将创建一个新文件夹`hello_utils`，里面有一个`Cargo.toml`和`src`文件夹已准备好进行配置。为了告诉 Cargo，请打开`hello_world/Cargo.toml`，并添加你的`hello_utils`依赖:

```toml
[dependencies]
hello_utils = { path = "hello_utils" }
```

这告诉 Cargo 我们依赖于一个叫做`hello_utils`的箱子，这能在`hello_utils`文件夹找到(相对于，写在`Cargo.toml`路径).

就是这样! 下一步`cargo build`将自动构建`hello_utils`，以及它自己的所有依赖项，其他人也可以开始使用它。但是，[crates.io](https://crates.io/)不允许仅使用 **路径指定依赖项** 的包。如果我们想发布我们的`hello_world`箱子，我们需要发布一个版本`hello_utils`至[crates.io](https://crates.io/)，并在依赖项行中指定其版本:

```toml
[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }
```

### 依赖覆盖

Cargo 中有许多方法支持，覆盖依赖关系以及控制依赖关系图。但是，这些选项通常仅在工作区级别可用，并且不通过依赖项传播。换句话说，"应用程序"具有覆盖依赖关系的能力，但"库"却没有。

许多场景，会产生想，覆盖依赖性或以其他方式改变某些依赖关系的愿望。然而，他们中的大多数都可以归结为，将箱子发布到 crates.io 之前使用箱子(覆盖依赖)的能力。例如:

- 您编写的 `crate` ，也用于您编写的更大应用程序中，并且您希望测试在更大应用程序内，`crate`的错误修复情况。
- 不是你编写的上游包，现在其 git 存储库的主分支上，有一个新功能或错误修复，您要测试它。
- 您即将发布新版本的 major 版本，但您希望在整个软件包中进行集成测试，以确保新的主要版本能够正常运行.
- 您已经为上游的软件包提交了一个针对您找到的错误的修复程序，但是您希望立即让您的应用程序依赖，此程序包的固定修复版本，以避免错误修复程序被拒绝合并.

这些场景目前都是通过[`[patch\]` 清单部分 ](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-patch-section)解决的，从历史上看，其中一些方案是[该`[replace\]`部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-replace-section)解决的，但我们在这里会记录`[patch]`解决的部分。

### 平台决定依赖

特定于平台的依赖项采用相同的格式，但在`target`下列出。像正常 Rust 一样的`#[cfg]`语法，将用于定义这些部分:

```toml
[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native = { path = "native/x86_64" }
```

与 Rust 一样，这里的语法支持`not`，`any`，和`all`运算符组合各种 cfg 名称/值对。请注意`cfg`语法仅在 Cargo 0.9.0(Rust 1.8.0)之后可用.

除了`#[cfg]`语法，Cargo 还支持列出依赖关系适用的完整目标:

```toml
[target.x86_64-pc-windows-gnu.dependencies]
winhttp = "0.4.0"

[target.i686-unknown-linux-gnu.dependencies]
openssl = "1.0.1"
```

如果您使用的是自定义目标规范，请引用完整路径和文件名:

```toml
[target."x86_64/windows.json".dependencies]
winhttp = "0.4.0"

[target."i686/linux.json".dependencies]
openssl = "1.0.1"
native = { path = "native/i686" }

[target."x86_64/linux.json".dependencies]
openssl = "1.0.1"
native = { path = "native/x86_64" }
```

### 开发依赖

你可以添加一个`[dev-dependencies]`表格到`Cargo.toml`，其格式相当于`[dependencies]`:

```toml
[dev-dependencies]
tempdir = "0.3"
```

编译用于构建的包时，不会使用 Dev 依赖，但用于编译测试，示例和基准。

这些依赖关系是*不会*传播到依赖于此包的其他包.

您还可以让`dev-dependencies`具有特定目标的开发依赖项，而不是`dependencies`标题。例如:

```toml
[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"
```

### 构建依赖

您可以在构建脚本中使用，依赖其他基于 Cargo 的箱。依赖关系是由清单的`build-dependencies`部分定义:

```toml
[build-dependencies]
cc = "1.0.3"
```

构建脚本**并不是**有权访问中 dependencies`要么`dev-dependencies`部分列出的依赖项`。除非也在`dependencies`部分下面列出，否则构建依赖项同样不可用于包本身。包本身及其构建脚本是分开构建的，因此它们的依赖关系不重合。通过将独立依赖用于独立目的，使 Cargo 更简单，更清洁。

### 选择特性

如果您依赖的包提供条件特性，您可以指定使用哪个:

```toml
[dependencies.awesome]
version = "1.3.5"
default-features = false # 不会包括默认特性， 和 任君选
                         # 单特性
features = ["secure-password", "civet"]
```

有关 features 的更多信息，请参阅[清单文档](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-features-section).

### 在Cargo.toml中重命名依赖

写`Cargo.toml`的`[dependencies]`部分的时候，您为依赖项编写的字段通常与您在代码中导入的包的名称相匹配。但是，对于某些项目，您可能希望在代码中引用具有不同名称的包，而不管它是如何在 crates.io 上发布的。例如，您可能希望:

- 避免在 Rust 代码常用`use foo as bar`.
- 依赖箱子的多个版本.
- 依赖来自不同注册表管理机构的同名箱.

为了支持这个 ，Cargo 在`[dependencies]`部分使用 一个`package`字段，决定应该依赖哪个包:

```toml
[package]
name = "mypackage"
version = "0.0.1"

[dependencies]
foo = "0.1"
bar = { git = "https://github.com/example/project", package = "foo" }
baz = { version = "0.1", registry = "custom", package = "foo" }
```

在此示例中，Rust 代码中现在提供了三个包:

```rust
extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`
```

所有这三个箱的包名称在他们自己`Cargo.toml`，都是`foo`，所以我们明确地告知 Cargo ，使用的是我们想要的`package`字段(如 package = "foo"包名，即我们在本地调用其他东西)。如果没有指定`package`，则默认为所请求的依赖项的名称。

请注意，如果您有一个可选的(optional)依赖项，例如:

```toml
[dependencies]
foo = { version = "0.1", package = 'bar', optional = true }
```

你依赖于一个`bar`箱子，其来自 crates.io，但你箱子有一个`foo`特性，取代了一个`bar`特性。也就是说，在重命名时，特性的名称拿掉了依赖项的名称，而不是包名称。

启用传递依赖项的工作方式类似，例如我们可以将以下内容，添加到上面的清单中:

```toml
[features]
log-debug = ['foo/log-debug'] # 使用 'bar/log-debug' 就会出现一个错误!
```

## 清单格式

每个包的这个`Cargo.toml`文件称为*清单*. 每个清单文件由一个或多个部分(表格)组成.

- [`[package\]` 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-package-section)
- [依赖项 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#dependency-sections)
- [`[profile.*\]` 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-profile-sections)
- [`[features\]` 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-features-section)
- [`[workspace\]` 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-workspace-section)
- [项目布局](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-project-layout)
- [Rust 示例](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#examples)
- [Rust 测试](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#tests)
- [配置一个 target](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#configuring-a-target)
- [`[patch]` 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-patch-section)
- [`[replace]` 部分](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-replace-section)

### [package]

`Cargo.toml`的第一部分是`[package]`.

```toml
[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
authors = ["Alice <a@example.com>", "Bob <b@example.com>"]
```

所有这三个字段都是必要性的.

#### version字段

Cargo 烘烤的概念是[语义版本控制](http://semver.org/)，所以确保你遵循一些基本规则:

- 在您达到 1.0.0 之前，任何事情都会发生，但是如果您进行了重大变化的更新，则增加次要(minor)版本。在 Rust 语言中，重大变化包括，向结构添加字段，或增加变量到枚举。
- 在 1.0.0 之后，只在增加主要(major)版本时进行重大变化。不要破坏建筑.
- 在 1.0.0 之后，不要在补丁级别(patch)的版本添加任何新的公共 API(没有任何新的`pub`)。如果添加`pub`结构、特性、字段、类型、函数、方法或其他任何东东，则总是增加次要版本。
- 使用具有三个数字部分的版本号，如 1.0.0，而不是 1.0。

#### edition字段

您可以在`Cargo.toml`中的`edition`字段，选择一个特定的 Rust 版本，用于您的包。

```toml
[package]
# ...
edition = '2024'
```

这个`edition`字段会影响到您的包编译的版本。若是通过`cargo new`得来的项目，Cargo 将始终让`edition`字段设置为最新版本。设置`[package]`下的`edition`字段将影响包中的所有目标/箱，包括测试套件、基准、二进制文件、示例等。

#### build字段

此字段指定包根目录中的文件，该文件是[构建脚本](https://rustwiki.org/zh-CN/cargo/reference/build-scripts.html)，用于生成本机代码。可以在构建脚本[指导](https://rustwiki.org/zh-CN/cargo/reference/build-scripts.html)中找到更多信息..

```toml
[package]
# ...
build = "build.rs"
```

#### links字段

此字段指定，要链接到的本机库名，更多信息可以在构建脚本指南的[`links`](https://rustwiki.org/zh-CN/cargo/reference/build-scripts.html#the-links-manifest-key)部分.

```toml
[package]
# ...
links = "foo"
build = "build.rs"
```

#### documentation字段

此字段指定托管箱(crate)文档的网站的 URL。如果清单文件中没有指定 URL，[crates.io](https://crates.io/)自动将你的箱子连接到相应的箱子的[docs.rs](https://docs.rs/)页.

来自特定主机的文档链接被列入黑名单。如果已知主机不承载文档，并且可能具有恶意意图，例如广告跟踪网络，则主机被添加到黑名单中。下列主机的 URL 就被列入黑名单:

- rust-ci.org

来自黑名单主机的文档 URL 将不会出现在 crates.io 上，并且可能被 docs.rs 链接替换。

#### exclude和include字段

出于打包和重建包的目的，您可以显式地指定一组[globs](https://docs.rs/glob/0.2.11/glob/struct.Pattern.md)模式，匹配项应被忽略或包含。如`exclude`字段标识了在发布包时，不包括的一组文件，以及检测何时重建包时，应该忽略的文件，而`include`就是显式指定一定包含的文件。

如果一个 VCS 被用于一个包，则`exclude`字段将被植入 VCS 的忽略设置(例如 Git 的`.gitignore`)。

```toml
[package]
# ...
exclude = ["build/**/*.o", "doc/**/*.md"]
[package]
# ...
include = ["src/**/*", "Cargo.toml"]
```

选项是相互排斥的: `include`设置覆盖`exclude`。 注意`include`必须是文件的详尽列表，否则可能不包括必要的源文件。

#### 转移成 类`gitignore` 模式匹配

这些配置的当前解释实现都基于 UNIX Globs，如[`glob`箱](https://crates.io/crates/glob)。 若是我们想要 Cargo 的`include`和`exclude`尽可能配置为类似于`gitignore`。可看看[这个`gitignore`规范](https://git-scm.com/docs/gitignore)，其也是基于 Globs 的，但是还有许多其他的特性，这些特性使模式编写更容易，控制也更多。因此，我们正在迁移这些配置规则的解释实现，以使用[`ignore`箱](https://crates.io/crates/ignore)，并认真对待`gitignore`文件的每一条行规则。见[跟踪问题](https://github.com/rust-lang/cargo/issues/4268)有关迁移的更多细节。

#### publish字段

这个`publish`字段通过错误，防止将包(crate)，发布到包注册中心(如*crates.io*)。

```toml
[package]
# ...
publish = false
```

#### workspace字段

这个`workspace`字段可用于配置此包将属于的工作区。如果没有指定，这将被推断为文件系统中第一个 Cargo.toml 的`[workspace]`。

```toml
[package]
# ...
workspace = "path/to/workspace/root"
```

#### 包元信息

`[package]`部分会接受许多可选的元数据字段:

```toml
[package]
# ...

# 关于包的简短介绍. 这不会以任何格式呈现
# 到 crates.io (又名 这不是markdown).
description = "..."

# 这些URL指向有关包的更多信息 这些是
# 旨在成为相关数据的网页入口， 不一定兼容
# VCS工具(类似的)等.
documentation = "..."
homepage = "..."
repository = "..."

# 这指向包根目录下的文件 (与 `Cargo.toml` 相对的).
# 该文件的内容会存储，并在注册表中编入索引。
# crates.io 将渲染此文件，并将结果放在包的页面上.
readme = "..."

# 这是一个，最多五个描述此箱的关键字的列表. 关键词
# 可以在 crates.io 上搜索, 和你可以选择任何单词
# 帮助别人找到这个箱子。
keywords = ["...", "..."]

# 这是此箱子最适合的(最多五个)类别的列表.
# 类别是 crates.io/category_slugs 上可用的固定列表, 和
# 他们必须完全匹配.
categories = ["...", "..."]

# 这是此包的SPDX 2.1许可证表达式.  目前
# crates.io将根据白名单的已知许可证和SPDX许可证列表2.4中的异常标识符，
# 验证提供的许可证。目前不支持括号。
#
# 使用AND和OR的许可证表达式
# 运算符以获得更明确的语义。
license = "..."

# 如果程序包使用非标准许可证, 则可以指定此 key
# 代替上述 key 和 必须指向相对于此清单的文件
# (类似于 readme key).
license-file = "..."

# 要在crates.io上显示的徽章规范，的可选项。
#
#  - 与当前可用的构建状态有关的徽章是
#   Appveyor, CircleCI, GitLab, 和 TravisCI.
# - 与代码测试覆盖有关的可用徽章是 Codecov 和
#   Coveralls.
# - 还有基于 isitmaintained.com的维护相关徽章
#   其中说明了问题解决时间，未决问题的百分比和未来
#   维护意图。
#
# 若要求一个`repository` key, 就表示一个`user/repo` 格式的存储库
[badges]

# Appveyor: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认), `bitbucket`, 和
# `gitlab`; `id` 是可选的; 如果你想改用，可以指定appveyor 项目ID.
# `project_name` 是可选的; 使用在 repository
# 名称 与 appveyor 项目名称 不同的情况.
appveyor = { repository = "...", branch = "master", service = "github" }

# Circle CI: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
circle-ci = { repository = "...", branch = "master" }

# GitLab: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
gitlab = { repository = "...", branch = "master" }

# Travis CI: `repository`为 "<user>/<project>"格式 是必须的.
# `branch` 是可选的; 默认为 `master`
travis-ci = { repository = "...", branch = "master" }

# Codecov: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认), `bitbucket`, 和
# `gitlab`.
codecov = { repository = "...", branch = "master", service = "github" }

# Coveralls: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认) 和 `bitbucket`.
coveralls = { repository = "...", branch = "master", service = "github" }

# 是否保持解决时间: `repository` 是必须的.
is-it-maintained-issue-resolution = { repository = "..." }

# 它是否保持未解决问题的百分比: `repository` 是必须的.
is-it-maintained-open-issues = { repository = "..." }

# Maintenance: `status` 是必须的. 可用的选项是 `actively-developed`,
# `passively-maintained`, `as-is`, `experimental`, `looking-for-maintainer`,
# `deprecated`, 和 默认为 `none`, 不会在 crates.io 显示徽章.
maintenance = { status = "..." }
```

#### metadata table

默认情况下，Cargo 将对`Cargo.toml`不使用的字段发出警告，协助检测错别字等。就像这个`package.metadata`表格，但是，完全不写了的话， Cargo 将不会被警告。这个表格可在`Cargo.toml`，用于将包配置存储好。 例如:

```toml
[package]
name = "..."
# ...

# 当要生成一个 Android APK，这个元信息会被使用, 例如.
[package.metadata.android]
package-name = "my-awesome-android-app"
assets = "path/to/static"
```

### 依赖部分

见[指定依赖-那页](https://rustwiki.org/zh-CN/cargo/reference/specifying-dependencies.html)有关`[dependencies]`，`[dev-dependencies]`，`[build-dependencies]`和特定目标的`[target.*.dependencies]`部分的信息。

### [profile.*]

Cargo 支持了，可通过顶层 配置文件(profile) 调用 rustc 的自定义配置。任何清单都可以声明一个配置文件，但是实际上只读取顶级包的配置文件。所有依赖项的配置文件都将被重写，这样做是为了让顶级包能够控制，其依赖项如何编译的。

目前有四个受支持的配置文件名称，它们都具有相同的配置。下面列出了可用的配置，以及每个配置文件的默认设置.

```toml
# 此为 开发配置文件, 给 `cargo build` 所使用.
[profile.dev]
opt-level = 0      # 控制编译器构建的`--opt-level`。
                   # 0-1适合调试。 2是良好优化的。最大为 3。
                   # 's' 企图优化大小, 'z' 则 进一步优化大小.
debug = true       # (u32 or bool) 包括调试信息（调试符号）.
                   # 相当于 `-C debuginfo=2` 编译器 标志.
rpath = false      # 控制 编译器 是否应该设置加载器路径.
                   # 若为 true, 传递 `-C rpath` 标志 给 编译器.
lto = false        # 链接时间优化通常会减少二进制文件和静态库的大小
                   # 但会增加编译时间.
                   # 若是 true, 传递 `-C lto` 标志 给 编译器, 和 若是一个
                   # 字符串值 像 'thin' ，那会传递 `-C lto=thin`
                   # 给 编译器
debug-assertions = true # 控制是否启用调试断言
                   # (e.g. debug_assert!() 和 算术溢出检查)
codegen-units = 16 # if > 1 并行代码生成，以改善
                   # 编译时间, 但阻止了些优化.
                   # 传递 `-C codegen-units`.
panic = 'unwind'   # 恐慌策略 (`-C panic=...`), 也可以是 'abort'
incremental = true # 是否启用增量编译
overflow-checks = true # 使用溢出检查进行整数运算。
                   # 传递 `-C overflow-checks=...`标志 给 compiler.

# 发布(release)的配置文件, 用于 `cargo build --release` (和 依赖项的
# `cargo test --release`,  包括本地 library 或 binary).
[profile.release]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 16
panic = 'unwind'
incremental = false
overflow-checks = false

# 测试的配置文件, 用于 `cargo test` (对于 `cargo test --release`，可看
# `release` 和 `bench` 配置文件).
[profile.test]
opt-level = 0
debug = 2
rpath = false
lto = false
debug-assertions = true
codegen-units = 16
panic = 'unwind'
incremental = true
overflow-checks = true

# 基准的配置文件, 用于`cargo bench` (和 要测试的目标 和
# 单元测试的 `cargo test --release`).
[profile.bench]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 16
panic = 'unwind'
incremental = false
overflow-checks = false
```

### [features]

Cargo 支持特性，允许表达:

- 条件编译选项(通过`cfg`属性);
- 可选的依赖项，增强了包，但不是必需的;还有
- 可选依赖项的簇，如`postgres`，其中就包括`postgres`包`postgres-macros`包，以及可能的其他包(如开发时的模拟库、调试工具等)。

包的特性也可以是可选的依赖项，也可以是一组其他特性。指定特性的格式是:

```toml
[package]
name = "awesome"

[features]
# 默认的可选包集。大多数人都想使用这些
# 包, 但它们是严格可选的。请注意，`session`不是包
# 而是此清单中列出的另一个功能。
default = ["jquery", "uglifier", "session"]

# 没有依赖关系的特性，主要用于条件编译，
# 像 `#[cfg(feature = "go-faster")]`.
go-faster = []

# `secure-password` 特性 需要 bcrypt 包. 这种别名
将允许人们以更高级别的方式讨论该 特性 和 允许
# 此软件包将在未来为该特性添加更多要求.
secure-password = ["bcrypt"]

# 特性可用于重新导出其他包的特性. `awesome`包的 `session`
# 特性将确保 cookie/session 也是可用的
session = ["cookie/session"]

[dependencies]
# 这些包是强制性的，是该软件包发行版的核心。
cookie = "1.2.0"
oauth = "1.1.0"
route-recognizer = "=2.1.0"

# 所以可选依赖项的列表, 其中一些是上面的
# `features`. 它们可以通过应用程序选择加入。
jquery = { version = "1.0.2", optional = true }
uglifier = { version = "1.5.3", optional = true }
bcrypt = { version = "*", optional = true }
civet = { version = "*", optional = true }
```

使用`awesome`包:

```toml
[dependencies.awesome]
version = "1.3.5"
default-features = false # 不包括默认功能，和可选,
                         # 任君选 个性化特性
features = ["secure-password", "civet"]
```

#### 规则

特性的使用遵循一些规则:

- 特性名称不能与清单中的其他包名称冲突。这是因为他们被选择加入`features = [...]`，而它只有一个命名空间。
- 除此`default`特性之外，所有的特性都是可选的。若要退出默认功能，请使用`default-features = false`，任君选择个人特性.
- 特性群组不允许周期性地相互依赖.
- 开发 依赖项不能是可选的.
- 特性群组只能引用可选的依赖项.
- 当选择一个特性时，Cargo 将调用具有`--cfg feature="${feature_name}"`的`rustc`。如果包含一个特性群组，那么它将包括所有单独的特性。这可以通过`#[cfg(feature = "foo")]`在代码中进行测试..

主要注意的是，显露的特性，实际上不激活任何可选的依赖项。这就允许包在不需要新的依赖项的情况下，于内部启用/禁用特性。

#### 生产终点的用法

该特性的一个主要用例是在最终产品中，指定可选特性。例如，Servo 包可能希望包含可选特性，人们可以在构建时，启用或禁用它。

在这种情况下，Servo 将在`Cargo.toml`描述特性，且用命令行标志来启用这些特性:

```console
$ cargo build --release --features "shumway pdf"
```

可以使用`--no-default-features`，排除默认特性。

### [workspace]

包可以定义一个工作区，它是一组箱，所有箱将共享相同`Cargo.lock`和输出目录。这个`[workspace]`表格可以定义为:

```toml
[workspace]

# 可选字段，从路径依赖推断（如果不存在）。
# 此处必须给出，包含的其他非路径依赖。
# 特别是, 对于 一个虚拟清单，所有成员都要列出来。
members = ["path/to/member1", "path/to/member2", "path/to/member3/*"]

# 可选字段, 如果不存在则为空
exclude = ["path1", "path/to/dir2"]
```

工作区作为 Cargo 的[RFC 1525](https://github.com/rust-lang/rfcs/blob/master/text/1525-cargo-workspace.md)一部分被添加到 Cargo 中，并具有许多属性:

- 工作区可以包含多个箱，其中一个是*根箱*.
- 这个*根箱*的`Cargo.toml`包含`[workspace]`表格，但不要求必有其他配置.
- 每当编译工作区中的任何箱时，输出被放置在*工作区根*。 即紧挨着*根箱*的`Cargo.toml`.
- 工作区中所有箱的那个锁定文件驻留在*工作区根*.
- 在`Cargo.toml`的`[patch]`，`[replace]`和`[profile.*]`部分，只认*根箱*的清单，而忽略成员箱的。

这个工作区的*根箱*，由其清单中存在的`[workspace]`指定，并负责定义整个工作区。所有驻留在工作区目录中的`path`依赖项都变成成员。您可以通过`members`字段将附加包添加到工作区中。请注意，显式列出的工作区成员，也在工作区中包含了它们的路径依赖项。有时候，一个包可能有很多工作区成员，并且都保持最新会很麻烦。

路径依赖也可以使用[globs](https://docs.rs/glob/0.2.11/glob/struct.Pattern.md)匹配多个路径。 最后，`exclude`字段 可以用于将工作路径中的路径列入黑名单。如果根本不希望某些路径依赖项存在于工作区中，那么这非常有用.

这个`package.workspace`清单字段(如上所述)用于成员箱中，以指向工作区的根箱。如果省略此字段，则推断它是文件系统(向上的父目录)中，清单包含`[workspace]`的第一个箱。

箱可以指定`package.workspace`或指定`[workspace]`。 也就是说，箱不能同时作为工作区中的根箱(包含`[workspace]`)，和另一个工作区的成员箱(包含`package.workspace`)

大多数时间工作区都不需要处理。因`cargo new`和`cargo init`将自动处理工作区配置。

#### 虚拟清单

在工作区清单中，如果`package`表格存在，则工作区根箱将被视为普通包和工作区。如果`package`表格不存在工作区清单中，那它被称为*虚拟清单*。

#### Package部分

在工作区中，与包相关的 Cargo 命令，如`cargo build`，会应用`-p` / `--package`或`--all`命令行参数选定的包。当未指定时，可选`default-members`配置被使用:

```toml
[workspace]
members = ["path/to/member1", "path/to/member2", "path/to/member3/*"]
default-members = ["path/to/member2", "path/to/member3/foo"]
```

`default-members`指定时，必会扩展到子集的`members`中.

若是`default-members`未指定，如果它是包，则默认为根清单，或者若是虚拟工作区，就为每个成员的清单(如同`--all`在命令行上).

### 项目布局

如果包是可执行文件，则将主源文件命名为`src/main.rs`。 如果它是一个库，请命名主源文件`src/lib.rs`。

Cargo 也将处理位于`src/bin/*.rs`任何文件作为可执行文件。如果可执行文件包含不止一个源文件，则可以使用`src/bin`目录下，又一个包含`main.rs`文件的目录，而该目录将被视为具有父目录名称的可执行文件。但是，一旦添加了`[[bin]]`部分[见下文](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#configuring-a-target)，Cargo 将不再自动建立`src/bin/*.rs`文件。 相反，你必须创建一个`[[bin]]`部分，给出你想要生成的每个文件。

您的包可以(可选地)包含命名为`examples`，`tests`和`benches`文件夹，Cargo 将分别将其视为包含示例、集成测试和基准。类似于`bin`目标，它们可以由单个文件或拥有`main.rs`文件的目录组成。

```
▾ src/           # 包含源文件的目录
  lib.rs         # 库和包的主要入口点
  main.rs        # 包生成可执行文件的主要入口点
  ▾ bin/         # （可选）包含其他可执行文件的目录
    *.rs
  ▾ */           # （可选）包含多文件可执行文件的目录
    main.rs
▾ examples/      # （可选）示例
  *.rs
  ▾ */           # （可选）包含多文件示例的目录
    main.rs
▾ tests/         # （可选）集成测试
  *.rs
  ▾ */           # （可选）包含多文件测试的目录
    main.rs
▾ benches/       # （可选）基准
  *.rs
  ▾ */           # （可选）包含多文件基准的目录
    main.rs
```

为了在创建文件和文件夹之后，为包构造代码，应该记住使用 Rust 的模块系统，您可以在这本[书](https://doc.rust-lang.org/book/crates-and-modules.md)找到。

### 示例

位于`examples`下方的文件，是库提供的功能示例用法。编译时，它们被放置在`target/examples`目录。

它们可以编译为可执行文件(用`main()`函数)或，库。和可通过使用`extern crate <library-name>`导入库。 当您运行测试以保护它们免遭篡改时，它们会被编译。

可以使用命令`cargo run --example <example-name>`运行单个可执行示例.

指定`crate-type`将示例编译为库(有关箱类型的附加信息可在[Rust 参考](https://doc.rust-lang.org/reference/linkage.html)找到):

```toml
[[example]]
name = "foo"
crate-type = ["staticlib"]
```

可以使用命令`cargo build --example <example-name>`构建单个库实例.

### 测试

当你运行`cargo test`，Cargo 会:

- 编译并运行库的单元测试，这些测试位于`lib.rs`(当然，任何标记为`#[cfg(test)]`部分将考虑为同个阶段);
- 编译并运行嵌入到文档区块内部的库的文档测试;
- 编译并运行您库的[集成测试](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#integration-tests)和
- 编译你库的例子.

#### 集成测试

在`tests/*.rs`的每个文件是一个集成测试。当你运行`cargo test`，Cargo 将编译每个文件作为一个单独的箱子。箱可以通过使用`extern crate <library-name>`链接(导入)您的库，就像其他导入项一样。

Cargo 不会自动编译`tests`子目录内的文件，但是，集成测试可以像往常一样从这些目录导入模块。例如，如果希望多个集成测试共享一些代码，可以将共享代码放入`tests/common/mod.rs`，然后为每个测试文件添加`mod common;`。

### Configuring a target

所有的`[[bin]]`，`[lib]`，`[[bench]]`，`[[test]]`和`[[example]]`部分都支持类似的配置，用于指定应该如何构建目标。双括号`[[bin]]`部分，是[TOML](https://github.com/toml-lang/toml#array-of-tables)格式的数组。这意味着你可以在您的箱中写多个`[[bin]]`，这样就会生成几个可执行文件。

下面的例子使用`[lib]`，但它也适用于所有其他部分。除非另有说明，下面所有列出的值都是对应选项的**默认值**。

```toml
[package]
# ...

[lib]
# 生成目标与库的名称. 本该默认是
# 包名, 替换所有破折号
# 为 下划线. (Rust `extern crate` 声明会参考该名;
# 因此，该值必须是可用的有效Rust标识符.)
name = "foo"

# 该字段，指向 crate 的入口(位置), 路径相对于 `Cargo.toml`.
path = "src/lib.rs"

# 一个给目标启用单元测试 的 标志. 会被 `cargo test`使用.
test = true

# 一个给目标启用文档测试 的 标志. 只与库相关
# , 不会影响其他部分。会被
# `cargo test`使用.
doctest = true

# 一个给目标启用基准 的 标志. 会被 `cargo bench`使用.
bench = true

# 一个给目标启用文档 的 标志. 会被 `cargo doc`使用.
doc = true

# 若该目标为 编译器扩展, 那要把该字段设为 true
# ，以让 Cargo 正确编译和，可用于所有依赖项.
plugin = false

# 若该目标为 "macros 1.1" 程序宏, 那要把该字段设为 true
proc-macro = false

# 若设为 false, `cargo test` 会为 rustc 省略 `--test` 标志, 这
# 阻止它生成测试工具 这在二进制存在，
# 构建管理测试运行器本身的情况下，有用.
harness = true

# 若设置了，那 目标会使用一个与`[package]`配置不同的版本
# , 也许是，编译一个库
2018年版本或，编译单元测试的2015年版本. 默认情况下
# 所有目标都使用`[package]`中指定的版本进行编译。
edition = '2015'
```

这个`[package]`还包括可选的`autobins`,`autoexamples`,`autotests`和`autobenches`，来明确 进入/退出 自动发现特定的目标种类。

#### required-features字段

这个`required-features`字段指定目标需要构建的特性。如果未选择任何所需的特性，则将跳过目标。这只与`[[bin]]`，`[[bench]]`，`[[test]]`和`[[example]]`部分有影响，它没有影响`[lib]`。

```toml
[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
# ...
required-features = ["postgres", "tools"]
```

#### 构建静态或者动态库

如果您的包生成一个库，则可以通过在`Cargo.toml`显式地指明构建的库类型:

```toml
# ...

[lib]
name = "..."
crate-type = ["dylib"] # 也能是 `staticlib`
```

可用的选项是`dylib`，`rlib`，`staticlib`，`cdylib`和`proc-macro`。 您应该只在包中使用一次此选项。Cargo 总是根据(包括的)包的要求来编译包(依赖项)。

您可以阅读[Rust 参考手册](https://doc.rust-lang.org/reference/linkage.html)中更多关于不同的箱类型

### [patch]

这部分可以用来[重写其他副本的依赖项](https://rustwiki.org/zh-CN/cargo/reference/specifying-dependencies.html#overriding-dependencies)。语法类似于`[dependencies]`部分:

```toml
[patch.crates-io]
foo = { git = 'https://github.com/example/foo' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz', branch = 'my-branch' }
```

这个`[patch]`表格由，类似依赖表格的子表组成。`[patch]`后的每个字段是正在修补的源 URL，或者`crates-io`(如果你正在修改[HTTPS://CRATESIO](https://crates.io/)注册表)。在上面的例子中，`crates-io`可以用 Git URL 替换，例如`https://github.com/rust-lang-nursery/log`；第二个示例中的`[patch]`部分使用此来指定一个名为`baz`的源。

这些表格中的每个项都是一个正常的依赖关系规范，与`[dependencies]`清单的部分一样。`[patch]`部分中列出的依赖项，被解析并用于在指定的 URL 上对源进行补丁。上面的清单片段补丁`crates-io`源(例如 crates.io 本身)的`foo`箱和`bar`箱。它也用一个来自其他地方的`my-branch`分支修补了`https://github.com/example/baz`源。

可以用不存在的箱版本来修补源，也可以用已经存在的箱版本来修补源。如果用源中已经存在的箱版本对源进行修补，则会替换源的原始箱。

有关重写依赖关系的更多信息，可阅读本文档的[重写依赖项](https://rustwiki.org/zh-CN/cargo/reference/specifying-dependencies.html#overriding-dependencies)章节和对于这一特性的[RFC 1969](https://github.com/rust-lang/rfcs/pull/1969)技术规范说明。

### [replace]

这部分可以用来[重写其他副本的依赖项](https://rustwiki.org/zh-CN/cargo/reference/specifying-dependencies.html#overriding-dependencies)。语法类似于`[dependencies]`部分:

```toml
[replace]
"foo:0.1.0" = { git = 'https://github.com/example/foo' }
"bar:1.0.2" = { path = 'my/local/bar' }
```

`[replace]`表格的每个字段都是[包标识规范](https://rustwiki.org/zh-CN/cargo/reference/pkgid-spec.html)，它任意选择依赖图中的节点来重写。每个字段值与`[dependencies]指定依赖关系的语法是一样，除了不能指定特性。注意，当覆盖一个箱时，覆盖它的副本必须具有相同的名称和版本，但它可以来自不同的源(例如，git 或本地路径).

有关重写依赖关系的更多信息，可阅读本文档的[重写依赖项](https://rustwiki.org/zh-CN/cargo/reference/specifying-dependencies.html#overriding-dependencies)章节。

## Workspace

工作*区*是一个或多个包的集合，这些包共享通用依赖项解析（使用共享`Cargo.lock`）、输出目录和各种设置（例如配置文件）。属于工作区的包称为*工作区成员*。工作区有两种类型：作为根包或作为虚拟清单。

### Root package

可以通过向 中添加一个[`[workspace\]` 部分](https://rustwiki.org/zh-CN/cargo/reference/workspaces.html#the-workspace-section)`Cargo.toml`来创建工作区。这可以添加到 `Cargo.toml`已经定义 的 中`[package]`，在这种情况下，包是工作区的Root package。工作区根目录是工作区所在的目录`Cargo.toml`。

### 虚拟清单

或者，`Cargo.toml`可以创建一个包含`[workspace]`部分 但没有[`[package\]`节 的](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-package-section)文件。这称为*虚拟清单*。这通常在没有“主”包或希望将所有包组织在单独的目录中时很有用。

## Feature

[Cargo“功能”提供了一种表达条件编译](https://rustwiki.org/zh-CN/reference/conditional-compilation.html)和 [可选依赖项](https://rustwiki.org/zh-CN/cargo/reference/features.html#optional-dependencies)的机制。包在`[features]`表中定义了一组命名功能`Cargo.toml`，每个功能都可以启用或禁用。可以使用诸如 之类的标志在命令行上启用正在构建的包的功能`--features`。可以在 中的依赖项声明中启用依赖项的功能`Cargo.toml`。

另请参阅[“功能示例”](https://rustwiki.org/zh-CN/cargo/reference/features-examples.html)章节，了解有关如何使用功能的一些示例。

### use

`[features]`功能在中的表格中定义`Cargo.toml`。每个功能指定一组它启用的其他功能或可选依赖项。以下示例说明了如何将功能用于 2D 图像处理库，其中可以选择包含对不同图像格式的支持：

```toml
[features]
# Defines a feature named `webp` that does not enable any other features.
webp = []
```

```rust
// This conditionally includes a module which implements WEBP support.
#[cfg(feature = "webp")]
pub mod webp;
```

```toml
[features]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
```

### The default feature

```toml
[features]
default = ["ico", "webp"]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
```

- The `--no-default-features` [command-line flag](https://rustwiki.org/zh-CN/cargo/reference/features.html#command-line-feature-options) disables the default features of the package.
- The `default-features = false` option can be specified in a [dependency declaration](https://rustwiki.org/zh-CN/cargo/reference/features.html#dependency-features).

### command

以下命令行标志可用于控制启用哪些功能：

- `--features` *FEATURES*：启用列出的功能。多个功能可以用逗号或空格分隔。如果使用空格，请确保在从 shell（例如）运行 Cargo 时使用引号括住所有功能。如果在[工作区](https://rustwiki.org/zh-CN/cargo/reference/workspaces.html)`--features "foo bar"`中构建多个包， 可以使用语法为特定工作区成员指定功能。`package-name/feature-name`
- `--all-features`：激活命令行上选择的所有包的所有功能。
- `--no-default-features`：不激活所选包的[`default` 功能。](https://rustwiki.org/zh-CN/cargo/reference/features.html#the-default-feature)

## Profiles

https://doc.rust-lang.org/cargo/reference/profiles.html

## Configuration

https://doc.rust-lang.org/cargo/reference/config.html

```toml
# 路径数组，指向本地将要覆盖依赖项的存储库.
# 更多信息，请看 指定 依赖项 指南.
paths = ["/path/to/override"]

[cargo-new]
# 这是你 放 name/email 的地方， 在一个新Cargo.toml中的
#`authors` 表格就会生成。若不存在， 那 `git` 会去调查， 若还是不
# 存在，那 `$USER` 和 `$EMAIL` 会被使用.
name = "..."
email = "..."

# 默认来说， `cargo new` 会初始化一个新的  Git repository. 该字段若设为 `hg` ，就是新建一个 Mercurial repository， 或 `none` 禁用此行为.
vcs = "none"

# 接下来的 部分， $triple 是 一些有效目标 triple的引用， 而不是一个字面量"$triple"的意思， 这个引用是无论何时都能应用编译的。
# 'cfg(...)' 是参考 类Rust `#[cfg]` 语法 (条件语句)
[target.$triple]
#  linker 可传递参数给 rustc (通过 `-C linker=`) 当 `$triple`
# 要被编译. 默认不传递东东
linker = ".."
# 一样，但这是传递给 rustc 关于 库压缩的参数 ，通过 `-C ar=`.
ar = ".."
# 若 提供了 一个 runner ， 编译`$triple`目标 会通过 执行 runner 执行文件来完成， 它会将真正的目标 作为第一参数.
# 这可运行 `cargo run`， `cargo test` 和 `cargo bench` 命令.
# 默认，编译目标是 直接执行的.
runner = ".."
# 自定义 全编译器，目标为 $triple
# 这些值会覆盖 build.rustflags
rustflags = ["..", ".."]

[target.'cfg(...)']
# 与 $triple 配置类似， 但使用的是 `cfg` 语法.
# 若有几个 `cfg` 和 $triple 目标作为备用， 那 rustflags
# 会被串联起来. 该 `cfg` 语法仅能应用到 rustflags， 而不能是
# linker.
rustflags = ["..", ".."]
# 与 $triple 配置类似 ， 但使用的是 `cfg` 语法.
# 若 一个或多个 `cfg`s， 和一个 a $triple 目标作为备用，那 该$triple将会被使用
# 若有几个 `cfg` 和 备用的， 那构建会 error
runner = ".."

# 关联到 注册表 的配置字段
[registry]
index = "..."   # 注册表索引的URL（默认为中央存储库）
token = "..."   # 访问令牌（在中央回购网站上找到）
default = "..." # 要使用的默认备用注册表（可以使用--registry覆盖）

[http]
proxy = "host:port" # 用于HTTP请求的HTTP代理（默认为none）
                    # libcurl格式，例如“socks5h://host:port”
timeout = 30        # 每个HTTP请求的超时，以秒为单位
cainfo = "cert.pem" # 证书颁发机构（CA）包的路径（可选）
check-revoke = true # 指示是否检查SSL证书是否已废除
low-speed-limit = 5 # 限速 字节/秒（10 = 默认值，0 = 禁用）
multiplexing = true # 是否在可能的情况下使用 HTTP/2多路复用

# 此设置可用于帮助调试Cargo所发生的HTTP请求
# 当设置为“true”时，将填充Cargo的正常调试日志记录
# 关于HTTP的信息，您可以使用
# `RUST_LOG=cargo::ops::registry=debug`提取（和`trace`可能会打印更多）。
#
# 在将这些日志发布到其他地方时要小心，因可能存在这样的
# header中，有一个你不想泄露的身份验证令牌的情况！务必
# 在发布之前简要查看日志。
debug = false

[build]
jobs = 1                  # 并行作业数，默认为CPU数
rustc = "rustc"           # rust编译器工具
rustdoc = "rustdoc"       # doc生成器工具
target = "triple"         # build为目标 triple（被`cargo install`忽略）
target-dir = "target"     # 放置所有生成的工件的路径
rustflags = ["..", ".."]  # 自定义 传递给所有编译器调用 的参数
incremental = true        # 是否启用增量编译
dep-info-basedir = ".."   # depfiles中，目标的基本目录的完整路径

[term]
verbose = false        # Cargo否提供详细输出
color = 'auto'         # Cargo否着色输出

# 网络配置
[net]
retry = 2 # 失败 自动重试 次数
git-fetch-with-cli = false  # 若为 `true` 我们会使用 `git`命令行去 fetch git repos

# 别名 cargo 命令. 前 3 个aliases 是内置的. 如果你的命令 要求 整行命令，请使用 list 格式.
[alias]
b = "build"
t = "test"
r = "run"
rr = "run --release"
space_example = ["run", "--release", "--", "\"command list\""]
```

## Environment Variables

Cargo 设置，并读取许多环境变量，代码可以检测或覆盖这些环境变量。以下是 Cargo 与它们交互时，组织的变量列表:

### Environment variables Cargo reads

Cargo 会读取的环境变量

您可以重写这些环境变量来更改 Cargo 在系统中的行为:

| 名(ENV)                  | 曰                                                           |
| ------------------------ | ------------------------------------------------------------ |
| `CARGO_HOME`             | Cargo 在本地缓存注册表索引和箱子的 git 版本。默认情况下，这些存储在`$HOME/.cargo`，但是这个变量重写了这个目录的位置。一旦箱被缓存，它就不会被清除命令删除。 |
| `CARGO_TARGET_DIR`       | 相对于当前工作目录，放置所有生成的工件的位置.                |
| `RUSTC`                  | Cargo 不运行`rustc`，而执行指定的编译器。                    |
| `RUSTC_WRAPPER`          | Cargo 将执行这个指定的包装器，而不是简单地运行`rustc`。将 rustc 调用 作为其命令行参数传递，第一个参数是 rustc. |
| `RUSTDOC`                | Cargo 将执行此指定的`rustdoc`实例，而不是`rustdoc`.          |
| `RUSTDOCFLAGS`           | 空格分隔的自定义标志列表，用来传递给 Cargo 执行的所有`rustdoc`调用 。与`cargo rustdoc`不同，这对于传递一个参数给 *全部的* `rustdoc`实例是有用的。 |
| `RUSTFLAGS`              | 自定义参数的空格分隔列表，用来传递给 Cargo 执行的所有编译器调用。与`cargo rustc`不同，这对于传递一个标志 *全部的* 编译实例是有用的。 |
| `CARGO_INCREMENTAL`      | 如果设置为 1，则 Cargo 将强制在当前编译中启用增量编译，而当设置为 0，则强制禁用增量编译。如果这个 ENV 不存在，否则将使用 Cargo 默认值。 |
| `CARGO_CACHE_RUSTC_INFO` | 如果这个设置为 0，那么 Cargo 将不尝试缓存编译器版本信息.     |

注意，Cargo 也会在`.cargo/config`配置中读取环境变量，如[那份文件](https://rustwiki.org/zh-CN/cargo/reference/config.html#environment-variables)

### Environment variables Cargo sets for crates

Cargo 为 crates 设置的环境变量

Cargo 在编译时，会将这些环境变量暴露在箱子中。请注意，这也适用于测试二进制文件。要在 Rust 程序中获得这些变量中的任何一个变量的值，请执行以下操作:

```rust
let version = env!("CARGO_PKG_VERSION");
```

`version`现在将包含了`CARGO_PKG_VERSION`值。

| 名                        | 曰                                                           |
| ------------------------- | ------------------------------------------------------------ |
| `CARGO`                   | 执行构建的二进制`cargo`路径.                                 |
| `CARGO_MANIFEST_DIR`      | 包含包的清单的目录.                                          |
| `CARGO_PKG_VERSION`       | 您的包的完整版本.                                            |
| `CARGO_PKG_VERSION_MAJOR` | 你的软件包的主要版本.                                        |
| `CARGO_PKG_VERSION_MINOR` | 您的包的次要版本.                                            |
| `CARGO_PKG_VERSION_PATCH` | 包的补丁版本.                                                |
| `CARGO_PKG_VERSION_PRE`   | 包的预发布版本.                                              |
| `CARGO_PKG_AUTHORS`       | 从程序包的清单中，冒号分隔出作者列表.                        |
| `CARGO_PKG_NAME`          | 你的包的名字.                                                |
| `CARGO_PKG_DESCRIPTION`   | 从包的清单中描述.                                            |
| `CARGO_PKG_HOMEPAGE`      | 从包的清单中的主页.                                          |
| `CARGO_PKG_REPOSITORY`    | 从包的清单中存储库.                                          |
| `OUT_DIR`                 | 如果包具有构建脚本，则将其设置为，构建脚本应该在其中放置其输出的文件夹。更多信息见下文. |

### Environment variables Cargo sets for build scripts

Cargo 为构建脚本设置的环境变量

当运行构建脚本时，Cargo 设置多个环境变量.因为编译生成脚本时还没有设置这些变量，所以上面的示例使用`env!`无法工作，而是在运行构建脚本时需要检索值:

```rust
use std::env;
let out_dir = env::var("OUT_DIR").unwrap();
```

`out_dir`现在将包含的价值`OUT_DIR`.

| 名                     | 曰                                                           |
| ---------------------- | ------------------------------------------------------------ |
| `CARGO`                | 执行构建的二进制`cargo`路径.                                 |
| `CARGO_MANIFEST_DIR`   | 包含正在构建的包的清单的目录(包含构建脚本的包)。还要注意，这是生成脚本启动时，当前工作目录的值. |
| `CARGO_MANIFEST_LINKS` | 清单`links`的值.                                             |
| `CARGO_FEATURE_<name>` | 对于正在构建的包的每个激活特性，此环境变量会让`<name>`功能名称存在，名称的`-`会转换成`_`. |
| `CARGO_CFG_<cfg>`      | 对正在构建包的每个[配置选项](https://doc.rust-lang.org/reference/attributes.md#conditional-compilation)，此环境变量将包含配置的值，其中`<cfg>`就是配置的名称，并将`-`翻译成`_`. 如果设置了布尔配置，则存在布尔配置，否则不存在。具有多个值的配置被连接到单个变量，该变量用`，`分隔就好。 |
| `OUT_DIR`              | 所有输出都应该放在这个文件夹。此文件夹位于正在构建的包的构建目录中，并且对于所讨论的包是唯一的。 |
| `TARGET`               | 正在编译的目标三元组。该为这个三元组编译本机代码。关于目标三元组的更多信息在[clang 自身文档中](http://clang.llvm.org/docs/CrossCompilation.md#target-triple). |
| `HOST`                 | Rust 编译器的主机三元组.                                     |
| `NUM_JOBS`             | 指定为顶层并行的并行性。这可以传递一个`-j`参数到系统(像`make`). 注意，在解释这个环境变量时应该小心。出于历史目的，仍然提供此功能，但是例如，最新版本的 Cargo 不需要运行`make -j`，因为它会自动。Cargo 自行实现[JooServer]，并且允许构建脚本继承这些信息，因此与 GNU 兼容的程序将使作业服务器已经具有适当配置的并行性。 |
| `OPT_LEVEL` ，`DEBUG`  | 为了分析，当前正在构建的相应变量值.                          |
| `PROFILE`              | 发布版本用`release`，而`debug`用于其他构建.                  |
| `DEP_<name>_<key>`     | 有关此组环境变量的更多信息，请参阅[`links`](https://rustwiki.org/zh-CN/cargo/reference/build-scripts.html#the-links-manifest-key). |
| `RUSTC` ，`RUSTDOC`    | Cargo 已经决定使用的编译器和文档生成器，传递给构建脚本，以便构建脚本也可以使用它. |
| `RUSTC_LINKER`         | 如果指定了，Cargo 为了当前目标，决定使用的链接器(二进制文件)的路径。这个链接器可以通过编辑`.cargo/config`更改，欲了解更多信息，请参阅有关文档[Cargo 配置](https://rustwiki.org/zh-CN/cargo/reference/config.html)。 |

### Environment variables Cargo sets for 3rd party subcommands

Cargo 为 第三方子命令设置的环境变量

Cargo 将这个环境变量公开给第三方子命令(即，名为`cargo-foobar`放置在`$PATH`):

- `CARGO` - 执行构建的二进制`cargo`路径。

## 构建脚本

一些包需要编译第三方非 Rust 代码，例如 C 库。其他的包需要链接到 C 库，当然这些库既可以位于系统上，也可以从源代码构建。其他人或许还需要功能工具，比如构建之前的代码生成(想想解析生成器)。

Cargo 并不打算替换为这些能良好优化任务的其他工具，但是它与`build`配置选项.

```toml
[package]
# ...
build = "build.rs"
```

指定的`build`命令应执行的 Rust 文件(相对于包根)，将在包编译其他内容之前，被编译和调用，从而具备 Rust 代码所依赖的构建或生成的工件。默认情况下 Cargo 在包根文件中寻找`"build.rs"`(即使您没有给`build`字段指定值)使用`build = "custom_build_name.rs"`指定自定义生成名，或`build = false`禁用对构建脚本的自动检测。

Build 命令的一些用例是:

- 构建一个捆绑的 C 库.
- 在主机系统上找到 C 库.
- 从规范中生成 Rust 模块.
- 为箱，执行所需的某平台特定配置.

下面将详细介绍每一个用例，以给出构建命令如何工作的示例.

### 输入到构建脚本

当运行构建脚本时，存在许多构建脚本用到的输入，所有输入都以[环境变量](https://rustwiki.org/zh-CN/cargo/reference/environment-variables.html)传入。

除了环境变量之外，构建脚本的当前目录是构建脚本包的源目录.

### 构建脚本的输出

由构建脚本打印到 stdout 的所有行都被写入像`target/debug/build/<pkg>/output`这样的文件(精确的位置可能取决于你的配置)。如果您希望直接在终端中看到这样的输出，那么使用非常详细`-vv`标志。注意，如果既不修改构建脚本也不修改包源文件，下一次的`-vv`调用将**不**打印重复输出到终端，因为没有执行新的构建。可执行`cargo clean`，如果希望确保输出始终显示在终端上，但要在每次 Cargo 调用之前执行。任何一行以`cargo:`开始的，直接由 Cargo 解释。行必须是`cargo:key=value`形式，就像下面的例子:

```
# specially recognized by Cargo
cargo:rustc-link-lib=static=foo
cargo:rustc-link-search=native=/path/to/foo
cargo:rustc-cfg=foo
cargo:rustc-env=FOO=bar
# arbitrary user-defined metadata
cargo:root=/path/to/foo
cargo:libdir=/path/to/foo/lib
cargo:include=/path/to/foo/include
```

另一方面，打印到 stderr 的行被写入像`target/debug/build/<pkg>/stderr`这样的文件，但不被 Cargo 解释。

Cargo 识别一些特殊的 key，其中一些影响箱的构造:

- `rustc-link-lib=[KIND=]NAME`说明了，指定值是库名，且会作为`-l`标志传递给编译器。`KIND`可选为`static`，`dylib`(默认值)，或`framework`的其中之一，用`rustc --help`见更多细节。
- `rustc-link-search=[KIND=]PATH`说明了，指定值是库搜索路径，且会作为`-L`标志传递给编译器。`KIND`可选为`dependency`，`crate`，`native`，`framework`或`all`(默认值)的其中之一，使用`rustc --help`见更多细节.
- `rustc-flags=FLAGS`是传递给编译器的一组标志，仅支持`-l`和`-L`标志。
- `rustc-cfg=FEATURE`说明了，指定的特性，且会作为`--cfg`标志传递给编译器。这通常对检测，执行各种特征的编译时间，是有用的。
- `rustc-env=VAR=VALUE`说明了，指定的环境变量，且会被添加到编译器所在的环境中。然后，可以通过编译箱中的`env!`宏检索该值。这对于在箱的代码中嵌入额外的元数据很有用，比如 Git HEAD 的散列，或持续集成服务器的唯一标识符。
- `rerun-if-changed=PATH`是文件或目录的路径，说明了如果构建脚本发生更改(由文件上最近修改的时间戳检测到)，则应重新运行构建脚本。通常，如果箱根目录中的任何文件发生更改，则重新运行构建脚本，但这可用于将更改范围扩展到仅一小组文件。(如果这个路径指向一个目录，则不会遍历整个目录以进行更改——只对目录本身的时间戳进行更改(该时间戳对应于目录中的某些类型的更改，取决于平台)，将触发重新构建。要请求重新运行整个目录中的任何更改，请递归地为该目录打印一行，为该目录内的所有内容打印另一行。)请注意，如果构建脚本本身(或其依赖项之一)更改，则无条件地重新构建和重新运行该脚本，因此，`cargo:rerun-if-changed=build.rs`几乎总是冗余(除非您想要忽略除了`build.rs`，所有其他文件的变化)
- `rerun-if-env-changed=VAR`是环境变量的名称，说明了它指示如果环境变量的值发生变化，则应重新运行构建脚本。这基本上与`rerun-if-changed`是一样的，除了它与环境变量一起工作。注意，这里的环境变量用于全局环境变量，如`CC`这样的，对于 Cargo 所设的像`TARGET`，就不必使用它。还要注意，如果`rerun-if-env-changed`打印出来，然后 Cargo 将*只*在，那些环境变量发生变化，或者打印出`rerun-if-changed`改变的文件的情况下，才重新运行构建脚本。
- `warning=MESSAGE`是构建脚本运行完毕后，打印到主控制台的消息/警告只针对路径依赖项(即，您在本地工作的那些依赖项)显示，因此如， crates.io 的箱在默认情况下不会打印警告。

其他哪些元素都是用户定义的元数据，这些元数据传递给了依赖的。关于这个的更多信息可以在[`links`](https://rustwiki.org/zh-CN/cargo/reference/build-scripts.html#the-links-manifest-key)部分查看.

### 构建依赖

构建脚本也可以依赖其他基于 Cargo 的箱。依赖关系通过清单的`build-dependencies`部分指定。

```toml
[build-dependencies]
foo = { git = "https://github.com/your-packages/foo" }
```

构建脚本**不**可以访问`dependencies`或`dev-dependencies`部分列表中的依赖项(它们还没有建成!)，除非明确声明，否则包本身也不能使用所有构建依赖项。

### links清单键

除了清单键`build`，Cargo 也支持一个，要链接到本地库的名称声明，那就是`links`清单键:

```toml
[package]
# ...
links = "foo"
build = "build.rs"
```

此清单说明了包会链接到本机库`libfoo`，并且它还具有定位和/或构建该本机库的构建脚本。Cargo 要求`build`如果有值，那`links`也要有值。

这个清单键的目的是，让 Cargo 了解包所具有的本地依赖项集合，并提供在包构建脚本之间，传递元数据的合适的系统.

首先，Cargo 要求一个包最多只有一个`links`值。换句话说，禁止两个包链接到同一个本机库。然而，这里也有[约定位置](https://rustwiki.org/zh-CN/cargo/reference/build-scripts.html#a-sys-packages)的方式，用来缓解这个问题。

如上面在输出格式中提到的，每个构建脚本可以以键-值对的形式生成一组任意的元数据。此元数据传递给**依赖的**包。例如，如果`libbar`依赖`libfoo`，当`libfoo`生成`key=value`作为其元数据的一部分，那`libbar`的构建脚本会有`DEP_FOO_KEY=value`环境变量。

注意，元数据只传递给直接依赖项，而不是把依赖项串起来。此元数据传递的动机，会在接下来，关联到系统库案例研究中概述。

### 覆盖构建脚本

如果一个清单包含`links`关键字，那 Cargo 支持重写用自定义库指定的构建脚本。此功能的目的是防止完全运行有问题的构建脚本，而是提前提供下元数据。

要覆盖构建脚本，请将下列配置放在任何可接受的 Cargo 的[配置位置](https://rustwiki.org/zh-CN/cargo/reference/config.html)中。

```toml
[target.x86_64-unknown-linux-gnu.foo]
rustc-link-search = ["/path/to/foo"]
rustc-link-lib = ["foo"]
root = "/path/to/foo"
key = "value"
```

本节说明目标`x86_64-unknown-linux-gnu`，命名为`foo`的库，具有指定的元数据。此元数据与构建脚本时生成的元数据相同，提供了许多键/值对，其中`rustc-flags`，`rustc-link-search`和`rustc-link-lib`有点特殊.

使用此配置，如果一个包声明它链接到此`foo`，那构建脚本将**不**编译或运行，而会使用指定的元数据。

## 发布到crates.io

一旦你有一个你想与世界分享的 crate，就该把它发布到[crates.io](https://crates.io/)! 发布是指，上载特定版本的，以让[crates.io](https://crates.io/)进行托管.

发布箱(crate)子时，要小心，因为发布是**常驻**。永远不能覆盖同版本，并且无法删除代码。但是，可以发布的版本数量没有限制。

### 在你开始发布前

首先，你需要一个[crates.io](https://crates.io/)帐户，用来获取 API 令牌。为此，[访问主页](https://crates.io/)，并通过 GitHub 帐户登录(现在需要)。在此之后，访问你的[帐号设定](https://crates.io/me)页面，并运行`cargo login`命令联通账号。

```console
$ cargo login abcdefghijklmnopqrstuvwxyz012345
```

此命令将告诉 Cargo 关于您的 API 令牌，并将其存储在您的本地`~/.cargo/credentials`(以前是`~/.cargo/config`)。请注意，此令牌是一个**秘密**，不应与其他任何人分享。如果因任何原因泄漏，您应立即重新生成。

### 在你创建新crate前

下一步是，将您的包装箱打包成可供[crates.io](https://crates.io/)上传的格式。为此，我们将使用`cargo package`子命令。这将把我们的整个包装箱全部打包成一个`*.crate`文件，其在`target/package`目录中。

```console
$ cargo package
```

作为一个额外的功能，`*.crate`将独立于当前源树进行验证。在`*.crate`创建之后，会解压到`target/package`目录，然后从头开始构建，以确保构建成功的所有必要文件。可以使用`--no-verify`参数禁用此行为。

现在是时候看看`*.crate`文件了，为了确保您不会意外地打包 2GB 视频资源，或用于代码生成，集成测试或基准测试的大型数据文件。目前存在 10MB 的`*.crate`文件上传大小限制。所以，如果`tests`和`benches`目录及其依赖项大小，最多只达 几 MB，您仍可以将它们保存在包; 不然的话，最好排除它们。

在打包时，Cargo 会自动忽略版本控制系统的忽略文件，但是如果要指定要额外的忽略文件集，则可以使用清单中的`exclude`字段:

```toml
[package]
# ...
exclude = [
    "public/assets/*",
    "videos/*",
]
```

这个数组中每个元素接受的语法是[rust-lang/glob](https://github.com/rust-lang/glob)。如果您宁愿使用白名单，而不是黑名单,Cargo 也支持`include`字段，如果设置,则会覆盖`exclude`字段:

```toml
[package]
# ...
include = [
    "**/*.rs",
    "Cargo.toml",
]
```

### 上传该crate

现在我们已经有了`*.crate`文件准备好了，可以上传到[crates.io](https://crates.io/)，接着使用`cargo publish`命令就好。就是这样，你现在已经发布了你的第一个箱子!

```console
$ cargo publish
```

如果你想跳过`cargo package`那一步，`cargo publish`如果找不到副本，子命令将自动打包本地包.

一定要看看[您可以指定的元数据](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#package-metadata)确保您的箱子更容易被发现!

### 为已存在的crate发布一个新版本

要发布新版本，请在`Cargo.toml`更改`version`为您指定的值。记住[semver 规则](https://rustwiki.org/zh-CN/cargo/reference/manifest.html#the-version-field)。然后可选择运行`cargo package`，如果你想检查一下`*.crate`发布前的新版本文件，然后运行`cargo publish`上传新版本.

### 管理一个基于creates.io的crate

箱的管理主要通过命令行完成`cargo`工具，而不是[crates.io](https://crates.io/)网络界面。为此，有一些子命令来管理包.

#### cargo yank

在您发布时，实际上可能会因某种原因，而最终破坏的箱子版本(语法错误，忘记包含文件等)的情况。对于诸如此类的情况，Cargo 支持一个箱子版本的"yank"。

```console
$ cargo yank --vers 1.0.1
$ cargo yank --vers 1.0.1 --undo
```

一个 yank **不是**删除任何代码。例如，此功能不用于删除意外上传的私钥。如果发生这种情况，您必须立即重置这些私钥.

一个 yank 版本的语义是，不为该版本创建新的依赖项，但所有现有的依赖项继续有效。[crates.io](https://crates.io/)其中一个主要目标是作为永久存档的箱子库，不会随着时间的推移而改变，而允许删除版本将违背这一目标。所以基本上，一个 yank 意味着所有包的`Cargo.lock`不会被破坏，在任何的未来，`Cargo.lock`生成的文件不会列出 yank 的版本。(成为了一个孤岛版本)

#### cargo owner

箱子通常由不止一个人开发，或者主要维护者可能会随着时间而改变!箱子的所有者是唯一允许发布新版本箱子的人，但是所有者可以指定其他所有者。

```console
$ cargo owner --add my-buddy
$ cargo owner --remove my-buddy
$ cargo owner --add github:rust-lang:owners
$ cargo owner --remove github:rust-lang:owners
```

给这些命令的所有者 ID 必须是 GitHub 用户名或 GitHub 团队.

如果用`--add`了一个用户名，那该用户成为"命名"所有者，拥有该箱子的完全权利。除了能够发布或 yank 箱子的版本，他们还能够添加或删除所有者，*包含*任命*他们*的所有者。毋庸置疑，你不应该让那些你不完全信任的人，作命名所有者。要成为命名所有者，用户必须之前就已登录[crates.io](https://crates.io/)。

如果用`--add`了一个团队，那该团队成为"团队"所有者，对箱的权利受到限制。虽然他们有权发布或 yank 箱子的版本，但他们*不*能够添加或删除所有者。除了更方便管理所有者群体之外，团队还可以更安全地防止恶意所有者。

团队的目前的语法是`github:org:team`(见上面的例子)。要将团队添加为所有者，必须是该团队的成员。删除所有者的团队就没有此类限制.

## 包ID规范

Cargo 的子命令经常需要引用依赖关系图中的特定包来进行各种操作，例如更新，清理，构建等。为了解决这个问题，Cargo 支持包 ID 规范。规范是一个字符串，用于唯一地引用依赖关系图中的一个包.

### 规范语法

包 ID 规范的形式语法是:

```notrust
pkgid := pkgname
       | [ proto "://" ] hostname-and-path [ "#" ( pkgname | semver ) ]
pkgname := name [ ":" semver ]

proto := "http" | "git" | ...
```

这里，括号表示内容是可选的.

### 规范示例

这些都可以是对`foo`包的引用，版本`1.2.3`，来自注册表`crates.io`

| pkgid                        | 名称  |  版本   |          网址          |
| :--------------------------- | :---: | :-----: | :--------------------: |
| `foo`                        | `foo` |   `*`   |          `*`           |
| `foo:1.2.3`                  | `foo` | `1.2.3` |          `*`           |
| `crates.io/foo`              | `foo` |   `*`   |  `*://crates.io/foo`   |
| `crates.io/foo#1.2.3`        | `foo` | `1.2.3` |  `*://crates.io/foo`   |
| `crates.io/bar#foo:1.2.3`    | `foo` | `1.2.3` |  `*://crates.io/bar`   |
| `http://crates.io/foo#1.2.3` | `foo` | `1.2.3` | `http://crates.io/foo` |

### 规范的简洁

这样做的目的是用简洁和详尽的语法来引用依赖图中的包。而不明确的引用可以指代一个或多个包。若使用相同的规范会引用多个包，那大多数命令都会生成错误。

## 换源

本文档是关于更换 crate 索引(注册表)。您可以阅读有关重写依赖项的信息，它在本文档的[重写依赖关系](https://rustwiki.org/zh-CN/cargo/reference/reference/specifying-dependencies.html#overriding-dependencies)部分。

Cargo 支持**用另一个来源更换一个来源**的能力，可根据镜像或 vendoring 依赖关系来表达倾向。要配置这些，目前通过[`.cargo/config`配置](https://rustwiki.org/zh-CN/cargo/reference/reference/config.html)机制完成，像这样:

```toml
# `source` 表下，就是存储有关要更换的来源名称
[source]

# 在`source` 表格之下的，可为一定数量的有关来源名称. 示例下面就# 定义了一个新源， 叫 `my-awesome-source`， 其内容来自本地 # `vendor`目录 ，其相对于包含`.cargo/config`文件的目录
[source.my-awesome-source]
directory = "vendor"

# Git sources 也指定一个 branch/tag/rev
git = "https://example.com/path/to/repo"
# branch = "master"
# tag = "v1.0.1"
# rev = "313f44e8"

# The crates.io 默认源 在"crates-io"名称下， 且在这里我们使用 `replace-with` 字段指明 默认源更换成"my-awesome-source"源
[source.crates-io]
replace-with = "my-awesome-source"
```

使用此配置，Cargo 会尝试在"vendor"目录中，查找所有包，而不是 查询在线注册表 crates.io 。Cargo 有两种来源更换的表达 :

- 供应(Vendoring) - 可以定义自定义源，它们表示本地文件系统上的包。这些源是它们正在更换的源的子集，并在需要时可以检入包中。
- 镜像(Mirroring) - 可以更换为等效版本的源，行为表现为 crates.io 本身的缓存。

Cargo 有一个关于来源更换的核心假设，源代码从两个完全相同的源而来。在上面的例子中，Cargo 假设所有的箱子都来自`my-awesome-source`，与`crates-io`副本完全相同。请注意，这也意味着`my-awesome-source`，不允许有`crates-io`源不存在的箱。

因此，来源更换不适用于依赖项补丁(fix bug)，或私有注册表等情况。Cargo 是通过使用[`[replace\]`字段](https://rustwiki.org/zh-CN/cargo/reference/reference/manifest.html#the-replace-section)支持依赖项补丁，计划为未来版本的 Cargo 提供私人注册表的支持。

### 配置

更换源的配置通过完成[`.cargo/config`](https://rustwiki.org/zh-CN/cargo/reference/reference/config.html)，下面为全套可用字段是:

```toml
# 每个源都有自己的表格，名称即是表名
[source.the-source-name]

# 命令 ，`the-source-name` 会被`another-source`取代
replace-with = "another-source"

# 有几种可用的源定义(接下来有所描述)
registry = "https://example.com/path/to/index"
local-registry = "path/to/registry"
directory = "path/to/vendor"
```

`crates-io`代表 crates.io 在线注册表(箱的默认来源)，可以更换为:

```toml
[source.crates-io]
replace-with = 'another-source'
```

### 注册表源

"注册表源"与 crates.io 本身相同。也就是说，它也有一个在 git 存储库中提供的索引，该存储库匹配[crates.io index](https://github.com/rust-lang/crates.io-index)的格式。然后该存储库具有指示从哪里下载包的配置。

目前还没有一个已经设置 crates.io 的镜像的可用项目。请继续关注!

### 本地注册表源

"本地注册表源"旨在成为另一个注册表源的子集，但可在本地文件系统(也称为 vendoring)上使用。本地注册表是提前下载，通常与一个 `Cargo.lock`同步，并由一组`*.crate`文件和像普通注册表一样的索引组成。

管理和创建本地注册表源的主要方法是通过[`cargo-local-registry`](https://crates.io/crates/cargo-local-registry)子命令，可在 crates.io 上找到，并用`cargo install cargo-local-registry`安装。

本地注册表包含在一个目录，其中包含许多从 crates.io 下载的`*.crate`文件，以及`index`目录，它与 crates.io-index 项目目录具有相同格式(仅填充有存在的 crates).

### 目录源

"目录源"类似于本地注册表源，其中包含本地文件系统上许多的可用包，适用于 vendoring 依赖项。与本地注册表一样，目录源主要由外部子命令管理[`cargo-vendor`](https://crates.io/crates/cargo-vendor)，可用`cargo install cargo-vendor`安装。

目录源与本地注册表不同，但它们包含`*.crate`文件的解压缩版本，使其在某些情况下，更适合检查所有内容到源代码控制工具。目录源只是一个包含许多其他目录的目录，其中包含 crates 的源代码(解压缩版本的`*.crate`文件)。目前，对每个目录的名称没有限制。

目录源中的每个包也有一个关联的元数据文件，指示包中每个文件的校验和，以防止意外修改。

## 外部工具

Cargo 的目标之一是与第三方工具(如 IDE 和其他构建系统)的简单集成。为了简化集成，Cargo 有几个设施:

- 一个`cargo metadata`命令，以 JSON 格式输出包结构和依赖关系信息，
- 一个`--message-format`标志，输出有关特定构建的信息，以及
- 支持自定义子命令.

### 包结构的资料

您可以使用`cargo metadata`命令，以获取有关包结构和依赖关系的信息。命令的输出如下所示:

```text
{
  // Integer 版本格式数字.
  "version": integer,

  // 工作区包的列表, 包括 依赖项.
  "packages": [
    {
      // 包 识别id 队列.
      "id": PackageId,

      "name": string,

      "version": string,

      "source": SourceId,

      // 确认依赖的一个列表, 可看 `resolve` 字段中的真实依赖.
      "dependencies": [ Dependency ],

      "targets: [ Target ],

      //  Cargo.toml 路径
      "manifest_path": string,
    }
  ],

  "workspace_members": [ PackageId ],

  // 依赖 关系图.
  "resolve": {
     "nodes": [
       {
         "id": PackageId,
         "dependencies": [ PackageId ]
       }
     ]
  }
}
```

格式稳定且有版本化。调用`cargo metadata`时，你应该通过`--format-version`明确标记，以避免向前不兼容的危险。

如果你正在使用 Rust，这有个[cargo_metadata](https://crates.io/crates/cargo_metadata)箱.

### 关于构建的资料

传递`--message-format=json`给，Cargo， 将在构建期间输出以下信息:

- 编译器错误和警告，
- 制作的工件，
- 构建脚本的结果(例如，本机依赖项).

输出以每行格式的 JSON 对象转到 stdout。`reason`字段区分不同类型的消息.

有关 Makefile 兼容格式的依赖关系的信息存储在工件旁的`.d`文件中。

### 自定义的子命令

Cargo 设计为，可以使用新的子命令进行扩展，而无需修改 Cargo 本身。这是通过转化一个 cargo `(?<command>[^ ]+)`的命令调用，变化为调用外部工具`cargo-${command}`来实现的。外部工具必须存在于用户其中一个`$PATH`目录中.

当 Cargo 调用自定义子命令时，子命令的第一个参数将像往常一样是自定义子命令的文件名。第二个参数将是子命令名称本身。例如，在调用`cargo-${command}`时，第二个参数是`${command}`。命令行上的其他所有参数将保持不变.

Cargo 还可以用`cargo help ${command}`显示自定义子命令的帮助输出。Cargo 假定子命令将在第三个参数出现时，打印帮助消息`--help`.所以，`cargo help ${command}`会调用`cargo-${command} ${command} --help`.

自定义子命令可以使用`CARGO`环境变量回调 Cargo。或者，它可以链接到作为一个库的`cargo`箱，但这种方法有缺点:

- Cargo 作为库是不稳定的:API 可能会更改，但不会弃用
- 链接的 Cargo 库的版本可能与 Cargo 二进制文件不同

